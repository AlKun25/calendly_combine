---
description: Data fetching and state management for Next.js 15 applications
globs: 
alwaysApply: false
---
# Data Fetching and State Management in Next.js 15

You are an expert in data fetching and state management for Next.js 15 applications. Follow these guidelines to implement efficient and maintainable patterns:

## Data Fetching Fundamentals

- Prefer server-side data fetching whenever possible
- Use the native `fetch()` API with proper caching configuration
- Understand the Next.js 15 caching behaviors
- Use proper loading and error handling with Suspense and error.js

## Fetch API Configuration in Next.js 15

```tsx
// Note: In Next.js 15, the default is now cache: 'no-store' (dynamic)
// This is a change from previous versions

// Dynamic data (default in Next.js 15)
const data = await fetch('https://api.example.com/data', { 
  cache: 'no-store'
});

// Static data (cached)
const data = await fetch('https://api.example.com/data', { 
  cache: 'force-cache'
});

// Revalidated data (ISR)
const data = await fetch('https://api.example.com/data', { 
  next: { revalidate: 60 } // Revalidate every 60 seconds
});
```

## Server Component Data Fetching Patterns

- Fetch data directly within the component without hooks
- Implement request deduplication through `fetch`'s built-in caching
- Use React 19's `use()` hook for more complex promise scenarios
- Waterfall requests vs parallel requests (implement parallelization when appropriate)
- Use tree structure to optimize data fetching

## Server Actions for Data Mutations

- Implement Server Actions for form handling and data mutations
- Use the `"use server"` directive to mark server functions
- Structure your mutations with proper validation and error handling
- Implement optimistic updates when appropriate
- Revalidate cached data after mutations

```tsx
// Server Action example
export async function updateUser(formData: FormData) {
  'use server'
  
  const name = formData.get('name')
  const email = formData.get('email')
  
  // Validation
  if (!name || !email) {
    throw new Error('Name and email are required')
  }
  
  // Update database
  await db.user.update({
    where: { id: session.user.id },
    data: { name, email }
  })
  
  // Revalidate path to refresh data
  revalidatePath('/profile')
}
```

## Client-side Data Fetching

- Use SWR or TanStack Query for client-side data needs
- Implement proper caching strategies
- Handle loading states and errors consistently
- Use libraries for complex data requirements

```tsx
'use client'

import { useQuery } from '@tanstack/react-query'

export function UserProfile() {
  const { data, isLoading, error } = useQuery({
    queryKey: ['user-profile'],
    queryFn: () => fetch('/api/profile').then(res => res.json())
  })
  
  if (isLoading) return <p>Loading...</p>
  if (error) return <p>Error loading profile</p>
  
  return (
    <div>
      <h1>{data.name}</h1>
      <p>{data.email}</p>
    </div>
  )
}
```

## State Management Hierarchy

1. **Local component state**: Use React's `useState` for component-specific state
2. **Shared component state**: Use React Context for sharing state within a subtree
3. **Global UI state**: Use Zustand, Jotai, or other lightweight state manager
4. **Server state**: Use SWR or TanStack Query for remote data that requires caching/syncing

## Zustand Implementation Pattern

```tsx
'use client'

import { create } from 'zustand'

interface CartState {
  items: Array<{ id: string; quantity: number }>;
  addItem: (id: string) => void;
  removeItem: (id: string) => void;
  clearCart: () => void;
}

export const useCartStore = create<CartState>((set) => ({
  items: [],
  addItem: (id) => set((state) => {
    const existingItem = state.items.find(item => item.id === id);
    if (existingItem) {
      return {
        items: state.items.map(item => 
          item.id === id ? { ...item, quantity: item.quantity + 1 } : item
        )
      };
    }
    return { items: [...state.items, { id, quantity: 1 }] };
  }),
  removeItem: (id) => set((state) => ({
    items: state.items.filter(item => item.id !== id)
  })),
  clearCart: () => set({ items: [] })
}));
```

## React Context Pattern

```tsx
'use client'

import { createContext, useContext, useState, ReactNode } from 'react'

type Theme = 'light' | 'dark'

interface ThemeContextType {
  theme: Theme;
  toggleTheme: () => void;
}

const ThemeContext = createContext<ThemeContextType | undefined>(undefined)

export function ThemeProvider({ children }: { children: ReactNode }) {
  const [theme, setTheme] = useState<Theme>('light')
  
  const toggleTheme = () => {
    setTheme(theme === 'light' ? 'dark' : 'light')
  }
  
  return (
    <ThemeContext.Provider value={{ theme, toggleTheme }}>
      {children}
    </ThemeContext.Provider>
  )
}

export function useTheme() {
  const context = useContext(ThemeContext)
  if (context === undefined) {
    throw new Error('useTheme must be used within a ThemeProvider')
  }
  return context
}
```

## Important Considerations

- Server Components cannot use client-side state management
- State management libraries must be used in Client Components
- Use `useState` for simple state, libraries for complex needs
- Consider performance impacts of your state management choices
- Implement proper loading and error states for all data operations

Remember: The key is choosing the right data fetching and state management pattern for your specific needs, not applying a one-size-fits-all approach.